# Description: This module provides a HarvestDB class that manages interactions with
# a SQLite database for logging the status of chemical data file downloads.
# It includes methods to log successful and failed downloads, as well as
# retrieve the current status of downloads for specific chemical IDs and file types.

# To create a new database, use the setupDB.py script in this folder.
# To clear out the database, use the clearDB.py script in this folder.

# Code generated by ChatGPT running within Github Copilot, based on a design
# worked out in Gemini, overseen and tested by AG

import sqlite3
from datetime import datetime
from typing import Optional, Dict, Any, Tuple
import logging
from file_types import FileTypes

logger = logging.getLogger(__name__)

# --- Configuration ---
DATABASE_FILE = 'chemview_harvest.db'
TABLE_NAME = 'harvest_log'
DATE_FORMAT = '%Y-%m-%d %H:%M:%S'


class HarvestDB:
    """
    Wrapper class for all database interactions with the harvest_log table.
    """

    def __init__(self, db_file: str = DATABASE_FILE):
        """Initializes the database connection file path."""
        self.db_file = db_file

    def _execute_query(self, sql: str, params: Tuple = ()) -> Optional[sqlite3.Cursor]:
        """Handles connecting, executing, committing, and closing the connection."""
        conn = None
        try:
            conn = sqlite3.connect(self.db_file)
            cursor = conn.cursor()
            cursor.execute(sql, params)
            conn.commit()
            return cursor
        except sqlite3.Error as e:
            logger.error("Database Error: %s", e, exc_info=True)
            return None
        finally:
            if conn:
                conn.close()

    def get_harvest_status(self, chemical_id: str, file_type: str) -> Optional[Dict[str, Any]]:
        """
        Retrieves the status record for a specific chemical_id and file_type.

        Returns a dict containing all columns, or None if the record doesn't exist.
        """
        # include the new navigate_via column
        sql = f"""
        SELECT local_filepath, last_success_datetime, last_failure_datetime, navigate_via
        FROM {TABLE_NAME}
        WHERE chemical_id = ? AND file_type = ?;
        """
        conn = None
        try:
            conn = sqlite3.connect(self.db_file)
            conn.row_factory = sqlite3.Row  # This allows accessing columns by name
            cursor = conn.cursor()
            cursor.execute(sql, (chemical_id, file_type))

            row = cursor.fetchone()
            if row:
                # Convert sqlite3.Row object to a standard dictionary
                return dict(row)
            return None

        except sqlite3.Error as e:
            logger.error("Database Read Error: %s", e, exc_info=True)
            return None
        finally:
            if conn:
                conn.close()

    def log_success(self, chemical_id: str, file_type: str, local_filepath: str, navigate_via: str) -> bool:
        """
        Logs a successful download. Sets success datetime and clears failure datetime.
        Uses INSERT OR REPLACE to either add a new record or update an existing one.
        """
        now = datetime.now().strftime(DATE_FORMAT)
        # When logging success we want to set the last_success_datetime and clear last_failure_datetime
        # navigate_via is required and records how the modal/link was navigated to
        sql = f"""
        INSERT OR REPLACE INTO {TABLE_NAME} 
        (chemical_id, file_type, local_filepath, last_success_datetime, last_failure_datetime, navigate_via)
        VALUES (?, ?, ?, ?, NULL, ?);
        """
        params = (chemical_id, file_type, local_filepath, now, navigate_via)
        return self._execute_query(sql, params) is not None

    def log_failure(self, chemical_id: str, file_type: str, navigate_via: str) -> bool:
        """
        Logs a failed download attempt. Updates the failure datetime.
        It preserves any existing success status and local_filepath.
        """
        now = datetime.now().strftime(DATE_FORMAT)

        # SQL to insert a new record if it doesn't exist, or update only the failure column (and navigate_via) if it does.
        sql = f"""
        INSERT INTO {TABLE_NAME} (chemical_id, file_type, last_failure_datetime, navigate_via) 
        VALUES (?, ?, ?, ?)
        ON CONFLICT (chemical_id, file_type) DO UPDATE SET
            last_failure_datetime = excluded.last_failure_datetime,
            navigate_via = excluded.navigate_via;
        """
        params = (chemical_id, file_type, now, navigate_via)
        return self._execute_query(sql, params) is not None


# --- Example Usage (Demonstration) ---
if __name__ == "__main__":
    # NOTE: You must run the setup script once before running this.
    db = HarvestDB()
    test_id = "CHEM_1234"
    # Use the centralized FileTypes constants for examples (keeps docs & code consistent)
    test_file_type = FileTypes.section5_pdf

    logger.info("--- 1. Check Initial Status ---")
    status = db.get_harvest_status(test_id, test_file_type)
    logger.info("Status before any action: %s", status)

    logger.info("--- 2. Log First Failure ---")
    db.log_failure(test_id, test_file_type, "somewhere")
    status = db.get_harvest_status(test_id, test_file_type)
    logger.info("Status after failure: %s", status)

    logger.info("--- 3. Log Success ---")
    file_path = f"/data/{test_id}_{test_file_type}.pdf"
    db.log_success(test_id, test_file_type, file_path, "somewhere")
    status = db.get_harvest_status(test_id, test_file_type)
    logger.info("Status after success: %s", status)

    logger.info("--- 4. Log a subsequent Failure (should keep success info) ---")
    db.log_failure(test_id, test_file_type, "somewhere")
    status = db.get_harvest_status(test_id, test_file_type)
    # The important part: last_success_datetime and local_filepath should remain populated.
    logger.info("Status after subsequent failure: %s", status)
