# Description: This module provides a HarvestDB class that manages interactions with
# a SQLite database for logging the status of chemical data file downloads.
# It includes methods to log successful and failed downloads, as well as
# retrieve the current status of downloads for specific chemical IDs and file types.

# To create a new database, use the setupDB.py script in this folder.
# To clear out the database, use the clearDB.py script in this folder.

# Code generated by ChatGPT running within Github Copilot, based on a design
# worked out in Gemini, overseen and tested by AG

import sqlite3
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, Tuple
import logging
from file_types import FileTypes

logger = logging.getLogger(__name__)

# --- Configuration ---
DATABASE_FILE = 'chemview_harvest.db'
TABLE_NAME = 'harvest_log'
DATE_FORMAT = '%Y-%m-%d %H:%M:%S'


class HarvestDB:
    """
    Wrapper class for all database interactions with the harvest_log table.
    """

    def __init__(self, db_file: str = DATABASE_FILE):
        """Initializes the database connection file path."""
        self.db_file = db_file

    def _execute_query(self, sql: str, params: Tuple = ()) -> Optional[sqlite3.Cursor]:
        """Handles connecting, executing, committing, and closing the connection."""
        conn = None
        try:
            conn = sqlite3.connect(self.db_file)
            cursor = conn.cursor()
            cursor.execute(sql, params)
            conn.commit()
            return cursor
        except sqlite3.Error as e:
            logger.error("Database Error: %s", e, exc_info=True)
            return None
        finally:
            if conn:
                conn.close()

    def get_harvest_status(self, chemical_id: str, file_type: str) -> Optional[Dict[str, Any]]:
        """
        Retrieves the status record for a specific chemical_id and file_type.

        Returns a dict containing all columns, or None if the record doesn't exist.
        """
        # include the new navigate_via column
        sql = f"""
        SELECT local_filepath, last_success_datetime, last_failure_datetime, navigate_via
        FROM {TABLE_NAME}
        WHERE chemical_id = ? AND file_type = ?;
        """
        conn = None
        try:
            conn = sqlite3.connect(self.db_file)
            conn.row_factory = sqlite3.Row  # This allows accessing columns by name
            cursor = conn.cursor()
            cursor.execute(sql, (chemical_id, file_type))

            row = cursor.fetchone()
            if row:
                # Convert sqlite3.Row object to a standard dictionary
                return dict(row)
            return None

        except sqlite3.Error as e:
            logger.error("Database Read Error: %s", e, exc_info=True)
            return None
        finally:
            if conn:
                conn.close()

    def log_success(self, chemical_id: str, file_type: str, local_filepath: str, navigate_via: str) -> bool:
        """
        Logs a successful download. Sets success datetime and clears failure datetime.
        Uses INSERT OR REPLACE to either add a new record or update an existing one.
        """
        now = datetime.now().strftime(DATE_FORMAT)
        # When logging success we want to set the last_success_datetime and clear last_failure_datetime
        # navigate_via is required and records how the modal/link was navigated to
        sql = f"""
        INSERT OR REPLACE INTO {TABLE_NAME} 
        (chemical_id, file_type, local_filepath, last_success_datetime, last_failure_datetime, navigate_via)
        VALUES (?, ?, ?, ?, NULL, ?);
        """
        params = (chemical_id, file_type, local_filepath, now, navigate_via)
        return self._execute_query(sql, params) is not None

    def log_failure(self, chemical_id: str, file_type: str, navigate_via: str) -> bool:
        """
        Logs a failed download attempt. Updates the failure datetime.
        It preserves any existing success status and local_filepath.
        """
        now = datetime.now().strftime(DATE_FORMAT)

        # SQL to insert a new record if it doesn't exist, or update only the failure column (and navigate_via) if it does.
        sql = f"""
        INSERT INTO {TABLE_NAME} (chemical_id, file_type, last_failure_datetime, navigate_via) 
        VALUES (?, ?, ?, ?)
        ON CONFLICT (chemical_id, file_type) DO UPDATE SET
            last_failure_datetime = excluded.last_failure_datetime,
            navigate_via = excluded.navigate_via;
        """
        params = (chemical_id, file_type, now, navigate_via)
        return self._execute_query(sql, params) is not None

    def delete_success_records(self, chemical_id: str) -> bool:
        """
        Deletes all success records for the given chemical_id from the database.
        """
        sql = f"""
        DELETE FROM {TABLE_NAME}
        WHERE chemical_id = ? AND last_success_datetime IS NOT NULL;
        """
        try:
            result = self._execute_query(sql, (chemical_id,))
            if result:
                logger.info("Deleted success records for chemical_id: %s", chemical_id)
                return True
            else:
                logger.warning("No success records found for chemical_id: %s", chemical_id)
                return False
        except Exception as e:
            logger.error("Error deleting success records for chemical_id %s: %s", chemical_id, e, exc_info=True)
            return False

    def need_download(self, chemical_id: str, file_type: str, retry_interval_hours: float = 12.0) -> bool:
        """
        Determine whether a download should be attempted for the given chemical_id and file_type.

        Policy:
        - If no record exists: return True
        - If a record has last_success_datetime (any success): return False
        - If no last_success and no last_failure: return True
        - If last_failure is within retry_interval_hours: return False
        - Otherwise return True (old failure)
        """
        record = self.get_harvest_status(chemical_id, file_type)
        if not record:
            logger.debug("No record found for %s / %s; download needed", chemical_id, file_type)
            return True

        last_success = record.get('last_success_datetime')
        last_failure = record.get('last_failure_datetime')

        if last_success:
            logger.debug("Found prior success for %s / %s; no download needed", chemical_id, file_type)
            return False

        if not last_failure:
            logger.debug("No prior failure recorded for %s / %s; download needed", chemical_id, file_type)
            return True

        # Parse the stored failure datetime. The DB stores strings using DATE_FORMAT.
        try:
            if isinstance(last_failure, str):
                last_failure_dt = datetime.strptime(last_failure, DATE_FORMAT)
            else:
                last_failure_dt = last_failure
        except Exception:
            logger.exception("Failed to parse last_failure_datetime for %s / %s", chemical_id, file_type)
            # conservative: if we can't parse the timestamp, do not retry
            return False

        if datetime.now() - last_failure_dt > timedelta(hours=retry_interval_hours):
            logger.debug("Prior failure for %s / %s is older than threshold; download needed", chemical_id, file_type)
            return True

        logger.debug("Prior failure for %s / %s is too recent; skipping download", chemical_id, file_type)
        return False

    def save_chemical_info(self, chemical_id: str, database_id: str, name: str) -> bool:
        """
        Ensure a chemical_info row exists for `chemical_id`.
        - If no row exists: insert (chemical_id, database_id, name).
        - If a row exists: if stored chemview_db_id or name differ from provided values, log an error and return False.
          Otherwise do nothing and return True.
        """
        conn = None
        try:
            conn = sqlite3.connect(self.db_file)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            cursor.execute(
                "SELECT chemview_db_id, name FROM chemical_info WHERE chemical_id = ?;",
                (chemical_id,)
            )
            row = cursor.fetchone()
            if row is None:
                # Insert new record
                sql = """
                      INSERT INTO chemical_info (chemical_id, chemview_db_id, name)
                      VALUES (?, ?, ?); \
                      """
                success = self._execute_query(sql, (chemical_id, database_id, name)) is not None
                if not success:
                    logger.error("Failed to insert chemical_info for %s", chemical_id)
                return success

            # Row exists: compare values
            existing_db_id = row["chemview_db_id"]
            existing_name = row["name"]
            if existing_db_id != database_id or existing_name != name:
                logger.error(
                    "chemical_info mismatch for %s: existing (chemview_db_id=%s, name=%s) != new (chemview_db_id=%s, name=%s)",
                    chemical_id, existing_db_id, existing_name, database_id, name
                )
                return False

            # No change needed
            return True

        except sqlite3.Error as e:
            logger.error("Database error in save_chemical_info: %s", e, exc_info=True)
            return False
        finally:
            if conn:
                conn.close()


# Module-level helper for backwards-compatible calls. Accepts either:
# - a HarvestDB instance
# - an object exposing get_harvest_status(chemical_id, file_type)
# - a path to the sqlite DB file (str)
def need_download_from_db(db_backend: Optional[Any], chemical_id: str, file_type: str, retry_interval_hours: float = 12.0) -> bool:
    if db_backend is None:
        logger.error("need_download_from_db called with no db_backend")
        return False

    # If caller passed a HarvestDB instance, delegate directly
    if isinstance(db_backend, HarvestDB):
        try:
            return db_backend.need_download(chemical_id, file_type, retry_interval_hours)
        except Exception:
            logger.exception("HarvestDB.need_download raised an exception")
            return False

    # If the backend exposes get_harvest_status, use it directly
    if hasattr(db_backend, 'get_harvest_status') and callable(getattr(db_backend, 'get_harvest_status')):
        try:
            record = db_backend.get_harvest_status(chemical_id, file_type)
        except Exception:
            logger.exception("DB read failed when checking need for %s / %s", chemical_id, file_type)
            return False

        if not record:
            return True
        if record.get('last_success_datetime'):
            return False
        if not record.get('last_failure_datetime'):
            return True
        try:
            lf = record.get('last_failure_datetime')
            last_failure_dt = datetime.strptime(lf, DATE_FORMAT) if isinstance(lf, str) else lf
        except Exception:
            logger.exception("Failed to parse last_failure_datetime for %s / %s", chemical_id, file_type)
            return False
        return datetime.now() - last_failure_dt > timedelta(hours=retry_interval_hours)

    # Otherwise assume db_backend is a path to the sqlite DB file
    try:
        tmp = HarvestDB(db_backend)
        return tmp.need_download(chemical_id, file_type, retry_interval_hours)
    except Exception:
        logger.exception("Failed to instantiate HarvestDB from db_backend; cannot determine need_download")
        return False



# Example usage / test harness moved to testDB.py to keep this module import-safe.
# Run `python testDB.py` to execute the HarvestDB tests.
