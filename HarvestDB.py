# Description: This module provides a HarvestDB class that manages interactions with
# a SQLite database for logging the status of chemical data file downloads.
# It includes methods to log successful and failed downloads, as well as
# retrieve the current status of downloads for specific chemical IDs and file types.

# To create a new database, use the setupDB.py script in this folder.
# To clear out the database, use the clearDB.py script in this folder.

# Code generated by ChatGPT running within Github Copilot, based on a design
# worked out in Gemini, overseen and tested by AG

import sqlite3
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, Tuple
import logging
from file_types import FileTypes

logger = logging.getLogger(__name__)

# --- Configuration ---
DATABASE_FILE = 'chemview_harvest.db'
TABLE_NAME = 'harvest_log'
DATE_FORMAT = '%Y-%m-%d %H:%M:%S'


class HarvestDB:
    """
    Wrapper class for all database interactions with the harvest_log table.
    """

    def __init__(self, db_file: str = DATABASE_FILE):
        """Initializes the database connection file path."""
        self.db_file = db_file

    def _execute_query(self, sql: str, params: Tuple = ()) -> Optional[sqlite3.Cursor]:
        """Handles connecting, executing, committing, and closing the connection."""
        conn = None
        try:
            conn = sqlite3.connect(self.db_file)
            cursor = conn.cursor()
            cursor.execute(sql, params)
            conn.commit()
            return cursor
        except sqlite3.Error as e:
            logger.error("Database Error: %s", e, exc_info=True)
            return None
        finally:
            if conn:
                conn.close()

    def get_harvest_status(self, chemical_id: str, file_type: str) -> Optional[Dict[str, Any]]:
        """
        Retrieves the status record for a specific chemical_id and file_type.

        Returns a dict containing all columns, or None if the record doesn't exist.
        """
        # include the new navigate_via column
        sql = f"""
        SELECT local_filepath, last_success_datetime, last_failure_datetime, navigate_via
        FROM {TABLE_NAME}
        WHERE chemical_id = ? AND file_type = ?;
        """
        conn = None
        try:
            conn = sqlite3.connect(self.db_file)
            conn.row_factory = sqlite3.Row  # This allows accessing columns by name
            cursor = conn.cursor()
            cursor.execute(sql, (chemical_id, file_type))

            row = cursor.fetchone()
            if row:
                # Convert sqlite3.Row object to a standard dictionary
                return dict(row)
            return None

        except sqlite3.Error as e:
            logger.error("Database Read Error: %s", e, exc_info=True)
            return None
        finally:
            if conn:
                conn.close()

    def log_success(self, chemical_id: str, file_type: str, local_filepath: str, navigate_via: str) -> bool:
        """
        Logs a successful download. Sets success datetime and clears failure datetime.
        Uses INSERT OR REPLACE to either add a new record or update an existing one.
        """
        now = datetime.now().strftime(DATE_FORMAT)
        # When logging success we want to set the last_success_datetime and clear last_failure_datetime
        # navigate_via is required and records how the modal/link was navigated to
        sql = f"""
        INSERT OR REPLACE INTO {TABLE_NAME} 
        (chemical_id, file_type, local_filepath, last_success_datetime, last_failure_datetime, navigate_via)
        VALUES (?, ?, ?, ?, NULL, ?);
        """
        params = (chemical_id, file_type, local_filepath, now, navigate_via)
        return self._execute_query(sql, params) is not None

    def log_failure(self, chemical_id: str, file_type: str, navigate_via: str) -> bool:
        """
        Logs a failed download attempt. Updates the failure datetime.
        It preserves any existing success status and local_filepath.
        """
        now = datetime.now().strftime(DATE_FORMAT)

        # SQL to insert a new record if it doesn't exist, or update only the failure column (and navigate_via) if it does.
        sql = f"""
        INSERT INTO {TABLE_NAME} (chemical_id, file_type, last_failure_datetime, navigate_via) 
        VALUES (?, ?, ?, ?)
        ON CONFLICT (chemical_id, file_type) DO UPDATE SET
            last_failure_datetime = excluded.last_failure_datetime,
            navigate_via = excluded.navigate_via;
        """
        params = (chemical_id, file_type, now, navigate_via)
        return self._execute_query(sql, params) is not None

    def delete_success_records(self, chemical_id: str) -> bool:
        """
        Deletes all success records for the given chemical_id from the database.
        """
        sql = f"""
        DELETE FROM {TABLE_NAME}
        WHERE chemical_id = ? AND last_success_datetime IS NOT NULL;
        """
        try:
            result = self._execute_query(sql, (chemical_id,))
            if result:
                logger.info("Deleted success records for chemical_id: %s", chemical_id)
                return True
            else:
                logger.warning("No success records found for chemical_id: %s", chemical_id)
                return False
        except Exception as e:
            logger.error("Error deleting success records for chemical_id %s: %s", chemical_id, e, exc_info=True)
            return False

    def need_download(self, chemical_id: str, file_type: str, retry_interval_hours: float = 12.0) -> bool:
        """
        Determine whether a download should be attempted for the given chemical_id and file_type.

        Policy:
        - If no record exists: return True
        - If a record has last_success_datetime (any success): return False
        - If no last_success and no last_failure: return True
        - If last_failure is within retry_interval_hours: return False
        - Otherwise return True (old failure)
        """
        record = self.get_harvest_status(chemical_id, file_type)
        if not record:
            logger.debug("No record found for %s / %s; download needed", chemical_id, file_type)
            return True

        last_success = record.get('last_success_datetime')
        last_failure = record.get('last_failure_datetime')

        if last_success:
            logger.debug("Found prior success for %s / %s; no download needed", chemical_id, file_type)
            return False

        if not last_failure:
            logger.debug("No prior failure recorded for %s / %s; download needed", chemical_id, file_type)
            return True

        # Parse the stored failure datetime. The DB stores strings using DATE_FORMAT.
        try:
            if isinstance(last_failure, str):
                last_failure_dt = datetime.strptime(last_failure, DATE_FORMAT)
            else:
                last_failure_dt = last_failure
        except Exception:
            logger.exception("Failed to parse last_failure_datetime for %s / %s", chemical_id, file_type)
            # conservative: if we can't parse the timestamp, do not retry
            return False

        if datetime.now() - last_failure_dt > timedelta(hours=retry_interval_hours):
            logger.debug("Prior failure for %s / %s is older than threshold; download needed", chemical_id, file_type)
            return True

        logger.debug("Prior failure for %s / %s is too recent; skipping download", chemical_id, file_type)
        return False


# Module-level helper for backwards-compatible calls. Accepts either:
# - a HarvestDB instance
# - an object exposing get_harvest_status(chemical_id, file_type)
# - a path to the sqlite DB file (str)
def need_download_from_db(db_backend: Optional[Any], chemical_id: str, file_type: str, retry_interval_hours: float = 12.0) -> bool:
    if db_backend is None:
        logger.error("need_download_from_db called with no db_backend")
        return False

    # If caller passed a HarvestDB instance, delegate directly
    if isinstance(db_backend, HarvestDB):
        try:
            return db_backend.need_download(chemical_id, file_type, retry_interval_hours)
        except Exception:
            logger.exception("HarvestDB.need_download raised an exception")
            return False

    # If the backend exposes get_harvest_status, use it directly
    if hasattr(db_backend, 'get_harvest_status') and callable(getattr(db_backend, 'get_harvest_status')):
        try:
            record = db_backend.get_harvest_status(chemical_id, file_type)
        except Exception:
            logger.exception("DB read failed when checking need for %s / %s", chemical_id, file_type)
            return False

        if not record:
            return True
        if record.get('last_success_datetime'):
            return False
        if not record.get('last_failure_datetime'):
            return True
        try:
            lf = record.get('last_failure_datetime')
            last_failure_dt = datetime.strptime(lf, DATE_FORMAT) if isinstance(lf, str) else lf
        except Exception:
            logger.exception("Failed to parse last_failure_datetime for %s / %s", chemical_id, file_type)
            return False
        return datetime.now() - last_failure_dt > timedelta(hours=retry_interval_hours)

    # Otherwise assume db_backend is a path to the sqlite DB file
    try:
        tmp = HarvestDB(db_backend)
        return tmp.need_download(chemical_id, file_type, retry_interval_hours)
    except Exception:
        logger.exception("Failed to instantiate HarvestDB from db_backend; cannot determine need_download")
        return False


# --- Example Usage (Demonstration) ---
if __name__ == "__main__":
    # NOTE: You must run the setup script once before running this.
    db = HarvestDB()
    test_id = "CHEM_1234"
    # Use the centralized FileTypes constants for examples (keeps docs & code consistent)
    test_file_type = FileTypes.section5_pdf

    logger.info("--- 1. Check Initial Status ---")
    status = db.get_harvest_status(test_id, test_file_type)
    logger.info("Status before any action: %s", status)

    logger.info("--- 2. Log First Failure ---")
    db.log_failure(test_id, test_file_type, "somewhere")
    status = db.get_harvest_status(test_id, test_file_type)
    logger.info("Status after failure: %s", status)

    logger.info("--- 3. Log Success ---")
    file_path = f"/data/{test_id}_{test_file_type}.pdf"
    db.log_success(test_id, test_file_type, file_path, "somewhere")
    status = db.get_harvest_status(test_id, test_file_type)
    logger.info("Status after success: %s", status)

    logger.info("--- 4. Log a subsequent Failure (should keep success info) ---")
    db.log_failure(test_id, test_file_type, "somewhere")
    status = db.get_harvest_status(test_id, test_file_type)
    # The important part: last_success_datetime and local_filepath should remain populated.
    logger.info("Status after subsequent failure: %s", status)

    logger.info("--- 5. Delete Success Records ---")
    db.delete_success_records(test_id)
    status = db.get_harvest_status(test_id, test_file_type)
    logger.info("Status after deleting success records: %s", status)

    logger.info("--- 6. Check Need for Download ---")
    # This will use the need_download method
    need_download = db.need_download(test_id, test_file_type)
    logger.info("Need download (after success and failure): %s", need_download)

    logger.info("--- 7. Log Failure, then Check Need Download ---")
    db.log_failure(test_id, test_file_type, "somewhere")
    need_download = db.need_download(test_id, test_file_type)
    logger.info("Need download (after failure): %s", need_download)

    logger.info("--- 8. Wait and Retry Logic ---")
    # Simulate waiting by manually adjusting the last_failure_datetime
    future_time = (datetime.now() - timedelta(hours=13)).strftime(DATE_FORMAT)
    db.log_failure(test_id, test_file_type, "somewhere")
    db._execute_query(f"UPDATE {TABLE_NAME} SET last_failure_datetime = ? WHERE chemical_id = ? AND file_type = ?", (future_time, test_id, test_file_type))
    need_download = db.need_download(test_id, test_file_type)
    logger.info("Need download (after adjusting time): %s", need_download)

